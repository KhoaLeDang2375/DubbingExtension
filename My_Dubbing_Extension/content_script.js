const CHUNK_PREFETCH_COUNT = 3;

// üëâ 1. L·∫•y video ID t·ª´ URL YouTube
function getYouTubeVideoId() {
  const url = window.location.href;
  const patterns = [
    /v=([a-zA-Z0-9_-]{11})/,
    /youtu\.be\/([a-zA-Z0-9_-]{11})/,
    /embed\/([a-zA-Z0-9_-]{11})/,
    /shorts\/([a-zA-Z0-9_-]{11})/
  ];
  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match && match[1]) return match[1];
  }
  return null;
}

// üëâ 2. G·ª≠i message ƒë·∫øn background ƒë·ªÉ l·∫•y danh s√°ch chunk
function getTotalChunks(videoId) {
  return new Promise((resolve, reject) => {
    chrome.runtime.sendMessage({ type: "GET_TOTAL_CHUNK", videoId }, (response) => {
      if (response?.transcriptInfo) {
        resolve({
          list_chunks: response.transcriptInfo.list_chunks,
          need_translator: response.transcriptInfo.need_translator
        });
      } else {
        reject("Kh√¥ng th·ªÉ l·∫•y danh s√°ch chunk.");
      }
    });
  });
}

// üëâ 3. G·ª≠i message ƒë·ªÉ l·∫•y audio t·ª´ c√°c chunk
function getAudioChunkViaBackground(videoId, chunkIds, need_translator) {
  return new Promise((resolve, reject) => {
    chrome.runtime.sendMessage({
      type: "GET_TTS_URL",
      videoId: videoId,
      list_chunks_id: chunkIds,
      need_translator: need_translator
    }, (response) => {
      if (chrome.runtime.lastError) {
        console.error(`‚ùå L·ªói Chrome Messaging:`, chrome.runtime.lastError);
        return reject(new Error("L·ªói Chrome Messaging: " + chrome.runtime.lastError.message));
      }
      if (!response || !response.audioChunks || !Array.isArray(response.audioChunks)) {
        console.error(`‚ùå Response ho·∫∑c audioChunks kh√¥ng h·ª£p l·ªá:`, response);
        return reject(new Error("Response ho·∫∑c audioChunks kh√¥ng h·ª£p l·ªá"));
      }
      try {
        const blobs = response.audioChunks.map(chunk => {
          if (!chunk.audioData) {
            console.error(`‚ùå [Chunk ${chunk.chunk_id}] Thi·∫øu audioData`);
            return null;
          }
          const byteArray = new Uint8Array(chunk.audioData);
          return { chunk_id: chunk.chunk_id, blob: new Blob([byteArray], { type: "audio/webm; codecs=opus" }) };
        }).filter(chunk => chunk !== null);
        resolve(blobs);
      } catch (err) {
        console.error(`‚ùå L·ªói khi x·ª≠ l√Ω audioChunks:`, err);
        reject(new Error("L·ªói khi x·ª≠ l√Ω d·ªØ li·ªáu √¢m thanh"));
      }
    });
  });
}

// üëâ 5. Inject n√∫t v√†o giao di·ªán YouTube
function injectButton() {
  if (document.getElementById("tts-dubber-btn")) return;

  const container = document.querySelector(".ytp-right-controls");
  if (!container) return;

  const iconUrl = chrome.runtime.getURL('assets/imgbtn.png');

  const buttonHTML = `
    <div class="youtube-dubbing-button" id="tts-dubber-btn">
      <div class="youtube-dubbing-container">
        <div class="youtube-dubbing-logo">
          <img src="${iconUrl}" alt="youtube-dubbing">
        </div>
      </div>
    </div>`;

  container.insertAdjacentHTML('beforeend', buttonHTML);

  const btn = document.getElementById("tts-dubber-btn");
  btn.addEventListener("click", async () => {
    const video = document.querySelector("video");
    if (!video) return alert("‚ùå Kh√¥ng t√¨m th·∫•y video.");
    video.muted = true;
    video.pause();

    const videoId = getYouTubeVideoId();
    if (!videoId) return alert("‚ùå Kh√¥ng th·ªÉ l·∫•y video ID.");

    try {
      const { list_chunks, need_translator } = await getTotalChunks(videoId);
      startTTSPlayback(video, videoId, list_chunks, need_translator);
    } catch (error) {
      console.error("‚ùå L·ªói khi kh·ªüi ƒë·ªông dubbing:", error);
      alert("L·ªói khi l·∫•y d·ªØ li·ªáu l·ªìng ti·∫øng.");
    }
  });
}

// üëâ 6. Kh·ªüi ƒë·ªông MediaSource v√† ph√°t tu·∫ßn t·ª± c√°c chunk
async function startTTSPlayback(video, videoId, chunkList, need_translator) {
  const audio = new Audio();
  const mediaSource = new MediaSource();
  audio.src = URL.createObjectURL(mediaSource);
  audio.crossOrigin = "anonymous";

  let state = {
    currentChunkIndex: 0
  };
  const pendingChunks = {};
  let sourceBuffer;
  let isAudioPlaying = false;

  audio.onplay = () => console.log("‚úÖ [Audio] B·∫Øt ƒë·∫ßu ph√°t.");
  audio.onpause = () => console.log("‚è∏Ô∏è [Audio] T·∫°m d·ª´ng.");
  audio.onended = () => {
    isAudioPlaying = false;
    console.log("üîö Audio ended");
  };
  audio.onerror = (e) => {
    const err = audio.error;
    const message =
      err?.code === 1 ? "MEDIA_ERR_ABORTED" :
      err?.code === 2 ? "MEDIA_ERR_NETWORK" :
      err?.code === 3 ? "MEDIA_ERR_DECODE" :
      err?.code === 4 ? "MEDIA_ERR_SRC_NOT_SUPPORTED" :
      "L·ªói kh√¥ng x√°c ƒë·ªãnh.";
    console.error(`‚ùå [Audio] L·ªói khi ph√°t: code=${err?.code} ‚Üí ${message}`);
  };

  mediaSource.addEventListener("sourceopen", async () => {
    try {
      sourceBuffer = mediaSource.addSourceBuffer('audio/webm; codecs=opus');
      sourceBuffer.mode = 'sequence';
      console.log("‚úÖ [MediaSource] sourceBuffer ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o.");
      setupChunkQueue(mediaSource, sourceBuffer, chunkList, videoId, state, pendingChunks, need_translator, audio);
      sourceBuffer.addEventListener("error", (e) => {
        console.error("‚ùå SourceBuffer error:", e);
      });
      sourceBuffer.addEventListener("updateend", async function onceStartPlayback() {
        if (!isAudioPlaying && audio.buffered.length > 0 && audio.buffered.end(0) > 0) {
          try {
            await video.play();
            await audio.play();
            isAudioPlaying = true;
            console.log("üîä Audio started");
          } catch (err) {
            isAudioPlaying = false;
            console.error("‚ùå audio.play() error:", err);
            if (err.name === "NotAllowedError") {
              console.warn("‚ö†Ô∏è Tr√¨nh duy·ªát ch·∫∑n auto-play, y√™u c·∫ßu t∆∞∆°ng t√°c ng∆∞·ªùi d√πng.");
            }
          }
          sourceBuffer.removeEventListener("updateend", onceStartPlayback);
        }
      });
    } catch (err) {
      console.error("‚ùå [MediaSource] L·ªói khi m·ªü source:", err);
    }
  });

  video.addEventListener("pause", () => {
    if (isAudioPlaying) {
      audio.pause();
      isAudioPlaying = false;
      console.log("‚è∏Ô∏è [Sync] Video pause ‚Üí Audio pause");
    }
  });

  video.addEventListener("play", () => {
    if (!isAudioPlaying) {
      audio.currentTime = video.currentTime;
      isAudioPlaying = true;
      audio.play().catch(err => {
        console.warn("‚ö†Ô∏è Audio resume failed:", err);
      });
    }
  });

  video.addEventListener("seeked", () => {
    alert("‚ö†Ô∏è Kh√¥ng h·ªó tr·ª£ tua khi ƒëang d√πng ch·∫ø ƒë·ªô l·ªìng ti·∫øng TTS.");
    video.currentTime = audio.currentTime;
  });

  alert("üîä ƒê√£ b·∫≠t l·ªìng ti·∫øng TTS!");
}

// üëâ 7. T·∫£i v√† n·∫°p chunk v√†o SourceBuffer
async function setupChunkQueue(mediaSource, sourceBuffer, chunkList, videoId, state, pendingChunks, need_translator, audio) {
  const requestedChunks = new Set();
  const appendedChunks = new Set();
  const appendQueue = [];
  const PREFETCH_COUNT = CHUNK_PREFETCH_COUNT;
  const RETRY_LIMIT = 3;
  const BUFFER_MONITOR_INTERVAL = 1000;

  async function fetchChunks(chunkIds, retryCount = 0) {
    const filteredIds = chunkIds.filter(id => (!requestedChunks.has(id) && !appendedChunks.has(id)));
    if (filteredIds.length === 0) return;

    filteredIds.forEach(id => requestedChunks.add(id));
    try {
      const blobs = await getAudioChunkViaBackground(videoId, filteredIds, need_translator);
      const bufferPromises = blobs.map(chunk =>
        chunk.blob.arrayBuffer().then(buffer => {
          pendingChunks[chunk.chunk_id] = buffer;
        }).catch(err => {
          console.error(`‚ùå Buffer error for ${chunk.chunk_id}:`, err);
        })
      );
      await Promise.all(bufferPromises);

      if (appendQueue.length < PREFETCH_COUNT) {
        appendNextChunk();
      }
    } catch (e) {
      console.error("‚ùå L·ªói t·∫£i chunk:", e);
      if (retryCount < RETRY_LIMIT) {
        setTimeout(() => fetchChunks(chunkIds, retryCount + 1), 1000);
      } else {
        console.error(`‚ùå B·ªè qua sau ${RETRY_LIMIT} l·∫ßn:`, chunkIds);
        // FIX: Kh√¥ng tƒÉng state.currentChunkIndex, ƒë·ªÉ appendNextChunk qu·∫£n l√Ω
        filteredIds.forEach(id => requestedChunks.delete(id));
        appendNextChunk();
      }
    }
  }

  async function processAppendQueue() {
    if (mediaSource.readyState !== "open" || sourceBuffer.updating || appendQueue.length === 0) {
      return;
    }
    const { chunkId, buffer } = appendQueue.shift();
    try {
      sourceBuffer.appendBuffer(buffer);
      delete pendingChunks[chunkId];
      appendedChunks.add(chunkId);
      appendNextChunk();
    } catch (e) {
      console.error(`‚ùå Append error for ${chunkId}:`, e);
      setTimeout(() => processAppendQueue(), 100);
    }
  }

  async function appendNextChunk() {
    if (state.currentChunkIndex >= chunkList.length) return;

    while (appendQueue.length < PREFETCH_COUNT && state.currentChunkIndex < chunkList.length) {
      const chunkId = `${videoId}_${chunkList[state.currentChunkIndex]}`;
      if (pendingChunks[chunkId] && !appendedChunks.has(chunkId) && !appendQueue.some(item => item.chunkId === chunkId)) {
        appendQueue.push({ chunkId, buffer: pendingChunks[chunkId]});
      } else if (!pendingChunks[chunkId] && !appendedChunks.has(chunkId)) {
        fetchChunks([chunkId]);
        break;
      } else {
        state.currentChunkIndex++;
      }
    }

    processAppendQueue();

    // FIX: Ki·ªÉm tra chunk b·ªã b·ªè s√≥t tr∆∞·ªõc khi prefetch xa
    const nextToPrefetch = [];
    for (let i = state.currentChunkIndex; i < state.currentChunkIndex + PREFETCH_COUNT && i < chunkList.length; i++) {
      const nextChunkId = `${videoId}_${chunkList[i]}`;
      if (!pendingChunks[nextChunkId] && !requestedChunks.has(nextChunkId) && !appendedChunks.has(nextChunkId)) {
        nextToPrefetch.push(nextChunkId);
      }
    }
    if (nextToPrefetch.length > 0) {
      fetchChunks(nextToPrefetch);
    }
  }

  sourceBuffer.addEventListener("updateend", () => {
    processAppendQueue();
  });

  const bufferMonitor = setInterval(() => {
    if (sourceBuffer.updating || audio.buffered.length === 0) return;
    const missingChunks = [];
    for (let i = state.currentChunkIndex; i < state.currentChunkIndex + PREFETCH_COUNT && i < chunkList.length; i++) {
      const chunkId = `${videoId}_${chunkList[i]}`;
      if (!pendingChunks[chunkId] && !appendedChunks.has(chunkId) && !requestedChunks.has(chunkId)) {
        missingChunks.push(chunkId);
      }
    }
    if (missingChunks.length > 0) {
      fetchChunks(missingChunks);
    }
    appendNextChunk();
  }, BUFFER_MONITOR_INTERVAL);

  const initialChunkIds = [];
  for (let i = state.currentChunkIndex; i < state.currentChunkIndex + PREFETCH_COUNT && i < chunkList.length; i++) {
    const chunkId = `${videoId}_${chunkList[i]}`;
    if (!pendingChunks[chunkId]) initialChunkIds.push(chunkId);
  }

  await fetchChunks(initialChunkIds);
  appendNextChunk();

  audio.addEventListener("ended", () => clearInterval(bufferMonitor));
}

// üëâ 8. Theo d√µi thay ƒë·ªïi URL (YouTube SPA)
let lastUrl = location.href;
new MutationObserver(() => {
  if (location.href !== lastUrl) {
    lastUrl = location.href;
    setTimeout(injectButton, 1000);
  }
}).observe(document, { subtree: true, childList: true });

// üëâ 9. Inject ban ƒë·∫ßu
setInterval(injectButton, 1500);